\documentclass{cours}
\usepackage{qtree}
\title{TD de TIC}
\author{Mohamed Kadhem Karray}

\begin{document}
\part{TD3}
\section{Exercice 1}
Soit $c$ un code PF. Soit $x_1, \ldots, x_{k}, y_{1}, \ldots, y_{l}$ pour lesquels il y a égalité. Alors, soit $i = \min \{i \in \N \mid x_{i} \neq y_{i}\}$. Alors en ne comptant que les $i$ premiers caractères du mot de départ, selon la longueur des codes, ou bien $c(x_{1},\ldots x_{i - 1})$ est un préfixe de $c(y_{1}, \ldots, y_{i - 1})$ ou bien l'inverse.

\section{Exercice 2}
\subsection{Question 1}
$c$ est un code PF. 

\subsection{Question 2}
Pour déchiffrer le code, il suffit de regarder le premier $0$ que l'on trouve. On choisit entre $1, 2$ et $3$ pour le déchiffrer selon la valeur modulo $3$ du nombre de $1$ qui le suivent. 

\section{Exercice 3}
J'ai une tête de cloche à fromage ouuuuuuuuuuuu ?

\section{Exercice 4}
\subsection{Question 1}
On considère $\mathcal{U}_{m} = \left\{u \in \mathcal{U} \mid l(u) \leq m\right\}$. On a alors, puisque $\mU_{m}$ est fini, l'existence de $l_{max, m} = \max \left\{l(u) \mid u \in \mU_{m}\right\} \leq m$. \\
On considère ensuite $c_{m}$ le code $c$ tronqué à $\mU_{m}$. On a :  
% \[
%     \begin{aligned}
%         \left(\sum_{u \in \mU}D^{-l(u)}\right)^{n} =& \sum_{x_{1}^{n}\in \mU^{n}}D^{-l(x_{1}) - \ldots - l(x_{n})}\\
%         =& \sum_{k \geq 1} \alpha(k)D^{-k}\
%         \leq & \sum_{k = 1}^{nl_{max, m}}\alpha(k)D^{-k}\\
%         = & nl_{max, m}
%     \end{aligned}
% \]
% Ainsi, 
% \[
%     \sum_{u \in \mU} D^{-l(u)} \leq (nl_{max, m})^{1/n} \xrightarrow[n\to \infty]{} 1
% \]
La suite des $\mU_{m}$ est croissante et on a $\limsup \mU_{m} = \mU$. Donc, par passage à la limite supérieure, on a bien 
\[
    \sum_{u \in \mU}D^{-l(u)} \leq 1
\]

\subsection{Question 2}
% On note $l_{1} = \abs{c(u_{1})} \leq \ldots \leq l_{n} = \abs{c(u_{n})} \leq \ldots$ les valeurs de $l(u)$. On prend comme $i$-ème mot code les $l_{i}$ premiers chiffres après la virgule dans le développement en base $D$ de $\sum_{j = 1}^{i - 1} D^{-l_{j}}$.\\
% Puisque cette somme est à termes strictement positifs et toujours inférieure à $1$, on a bien un code $PF$: les $l_{i}$ premiers chiffres de $c(u_{j})$ forment un nombre plus grand que $c(u_{i})$.
On retire, à partir de la profondeur $l(1)$ une proportion $\alpha_{1}D^{-l(1)}$ des branches. On définit une mesure $\mu$ sur les fils de l'arbre comme la proportion des feuilles de l'arbre qu'ils recouvrent. \\
On note $A_{i}$ l'union des fils enracinés à profondeur $l(i)$ qu'on a utilisés pour du codage de longueur $l(i)$. On a $\mu(A_{i}) = \alpha_{i}D^{-l(i)}$. Notre codage complet est l'union des $A_{i}$. On a alors : 
\[
    \mu\left(\bigcup_{i \in \N^{*}} A_{i}\right) = \sum_{i = 1}^{n} \mu(A_{i}) = \sum_{i = 1}^{n}\alpha(i)D^{-l(i)} = \sum_{u \in \mU} D^{-l(u)} \leq 1
\]
Donc on n'a pas de recouvrement des arbres. 

za
\section{Exercice 5}
\subsection{Question 1}
On code chaque nombre en base $2$ sur $k$ bits. On demande pour chaque bit si le nombre a la même valeur. Bah on a trouvé.

\subsection{Question 2}
On utilise le code $c_{2}(k)$ sur les $K$ objets. 
Puisque le code est PF, on peut juste regarder pour tout $i$ le $i$-ème symbole, et en fonction de ce qu'on a lu sur les $i-1$ premiers, lorsqu'on arrive à la fin du code, on a trouvé le résultat. 
On a $E[l(c_{2}(U))]$ questions en moyenne et donc on a bien : 
\[
    H_{2}(U) \leq E[l(c_{2})(U)] \leq H_{2}(U) + 1
\]
Pour tout $u \in \{1, \ldots, K\}$, on utilise $\lceil\log_{2}(p_{u})\rceil$ questions.


\subsection{Question 3}
Le nombre moyen de questions d'un questionnaire est équivalent à la longueur moyenne du codage UD qu'il représente. Par inégalité de Kraft et inégalité de Gibbs, on a : 
\[
    \begin{aligned}
        E[l(c)(k)] =& \sum_{k = 1}^{K}p_{k}l(c(k))\\
        =& -\sum_{k = 1}^{K}p_{k}\log_{2}(2^{-l(c(k))})\\
        \geq & -\sum p_{k}\log_{2}q_{k}\\
        \geq & -\sum p_{k}\log_{2}p_{k} \\
        = & H_{2}(U)
    \end{aligned}
\]
Donc le questionnaire a en moyenne au moins $H_{2}(U)$ questions. 

\subsection{Question 4}
On considère $U_{1},\ldots, U_{m}$ des réalisations i.i.d. de $U$. 
\begin{enumerate}
\item Avec $c_{2}$, en moyenne, on va utiliser : 
\[
    H_{2}(U) \leq \frac{1}{m}E[l(c_{2}(U_{1})) + \ldots + l(c_{2}(U_{m}))] \leq \frac{H_{2}(U) + 1}{m}
\]
\item Avec un code arbitraire, on va utiliser : 
\[
    H_{2}(U) \leq \frac{1}{m}E[l(c(U_{1})) + \ldots l(c(U_{m}))]
\]
\end{enumerate}


\subsection{Question 5}
On passe à la limite dans la question précédente. 

\part{TD4}
\section{Exercice 1}
On a : 
\[
	\begin{aligned}
		E[X] =& \int_{0}^{\infty}xf(x)\d x\\
		=& \int_{0}^{\infty}[xf_{X}(t)]_{0}^{t}\d t\\
		=& \int_{0}^{\infty}\int_{0}^{t}f_{X}(t)\d x \d t\\
		=& \int_{0}^{\infty}\int_{x}^{\infty}f_{X}(t)\d t\d x \text{\hspace{2cm} Fubini Tonelli}\\
		=& \int_{0}^{\infty}P(X\geq x)\d x
	\end{aligned}
\]

\section{Exercice 2}
On a : 
\[
	\begin{aligned}
		P(Y = y, Z = z | X = x) =& P(Y = y | Z = z, X = x)\times P(Z = z | X = x)\\
		=& f(x, y)\times P(Z = z | X = x)\\
	\end{aligned}
\]
Donc on a bien l'indépendance car 
\[
	P(Y = y | X = x) = \sum_{z \in Z(\Omega)} P(Y = y | X = x, Z = z) = f(x, y)
\]
\section{Exercice 3}
\begin{enumerate}
	\item On sépare à chaque étape les pièces en 3. Puisqu'une unique pièce est plus lourde, une balance suffit à trouver dans quel groupe la pièce la plus lourde est: Si l'un des ensembles pesés est plus lourd, c'est dans celui là, sinon, s'il y a égalité c'est dans le troisième. 
	\item Chaque pesée correspond à une manière de séparer les pièces en $3$. En particulier, l'arbre des possibilités correspondant à une stratégie arbitraire va être de hauteur au moins $\log_{3}(n)$. 
		La hauteur de l'arbre correspondant bien au nombre moyen de pesées\ldots
	\item On utilise la stratégie de la première question. On n'utilise alors jamais plus de $\lceil\log_{3}(n)\rceil$ pesée. Si $n = 3^{k}$, on revient au premier cas avec $\lfloor \log_{3}(n) \rfloor = k$ pesées.
	\item On calcule $H(U|Y) = \log_{3}(n) + \frac{\phi(p)}{\log(3)}$ où $\phi(p) = 2p\log p + (1 - 2p)\log(1 - p)$	
	\item On peut tester en deux pesées lors de la première étape si la pièce différente est plus lourde ou plus légère que les autres. En effet, si on sépare en trois ensembles $A, B, C$. Ou bien : $A < B$ et $B = C$ et la pièce est plus légère et dans $A$, ou bien $A < B$ et $B > C$ et la pièce est plus lourde et dans $B$. À renommage près, on applique la stratégie de 1) et on a le résultat. 
	L'entropie dit qu'on nécessiterait $k + \log_{3} 2$ pesées en moyenne, ce qui n'est pas entier. On a donc une solution optimale. 
\end{enumerate}

\section{Exercice 4}
\begin{enumerate}
	\item Il n'y a pas de feuilles manquantes à profondeur strictement inférieur à $x = max \abs{c(u)}$ puisqu'on minimise la longueur moyenne des codes. On a par ailleurs $B \leq D-2$ et $n + B = 1 + (D - 1)\alpha$. 
	\item Puisque tous les codes PF sont UD, le code de Huffman $D$-aire convient.
	\item L'arbre ternaire qu'on obtient est : \Tree [0 [10 11 12 ] ] \\
		On a alors $\bar{R_{s}} = 1.75$ et donc un taux de compression de $\frac{7/4}{\log_{3}{4}} = 1.39$
		Pour $D = 2$ on a l'arbre \Tree [$0$ [$10$ [$110$ $111$ ] ] ] ce qui donne $\bar{R_{s}} = 9/4$ et donc un taux de compression de $1.125$.
	\item Pour la distribution $p = \left(0.3, 0.2, 0.2, 0.15, 0.08, 0.07\right)$, on trouve 
		\begin{itemize}
			\item[Binaire] $L_{C} = 2.45$ et donc un taux de compression de $1.225$
			\item[Ternaire] $L_{C} = 1.65$ et donc un taux de compression de $1.012$ environ
		\end{itemize}
\end{enumerate}

\end{document}
